# なにができるツールなのか

ファイル単位でRepositoryを自動生成できる
LLMでSQLを書いて、sqlcでgolangから操作させて、関数を生成してインターフェースを実装する

# 使い方
llm-sqlc ファイル名
そのファイルの最初に存在するインターフェースを実装する。

ファイルの構造として、type XXXRepository interface {}の直後に、type XXxRepositoryImpl struct {}がある。

```
# Instruction
Please create SQL queries to implement the specified function for the given interface.
We are using sqlc to allow the generated SQL queries to be handled from Golang. Therefore, please ensure that the format of the generated SQL complies with sqlc.

# Function to be implemented
type XXXRepository interface {
}

We want to implement GetXXX for this XXXRepository.

# Important Notes
You are generating SQL only. There is no need to write the implementation of the function in a programming language.
Please ensure that the SQL queries are optimized for performance and do not cause issues like the N+1 problem.
In the function implementation, processing will be achieved by calling the SQL queries you generate.
It is preferable to have as few queries as possible, but you may use multiple queries if necessary.

# sqlc
The generated queries should include special comments as shown below. Make sure to correctly include the naming, the :one tag (or similar), and the placeholder settings.
We are using PostgreSQL as the DB.

-- name: GetAuthor :one
SELECT * FROM authors
WHERE id = $1 LIMIT 1;

-- name: ListAuthors :many
SELECT * FROM authors
ORDER BY name;

-- name: ListAuthorsByIDs :many
SELECT * FROM authors
WHERE id = ANY($1::int[]);

-- name: CreateAuthor :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING *;

-- name: UpdateAuthor :exec
UPDATE authors
  SET name = $2,
      bio = $3
WHERE id = $1;

-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = $1;

# DB Schema
Below is the schema of the database. Please generate the SQL queries based on this schema:
{{output schema.sql}}

# Entity Definition
The function we are implementing references the following Entity. Here are the type definitions and the definition of the New function for generating the Entity:

{{list the contents of the entity file}}

# Output Format
Output an array named `queries` containing the SQL queries required for the function implementation. The data type should be an array of strings.
If necessary, you can output multiple queries.
Each SQL query should start with a comment that is compliant with sqlc.
```

```
# Instruction
Please implement the function as specified with golang.

# Function to Implement
Implement the GetXXX function of the XXXRepository interface. This function should be implemented as a method on the following struct:

type XXXRepository interface {
}

type XXXRepositoryImpl struct {
}

var _ XXXRepository = XXXRepositoryImpl{}

# DB
You will communicate with the database using the code provided below.
## pkg/infra/db/db.go

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

## pkg/infra/db/models.go
{{output the contents of models.go}}

## pkg/infra/db/[corresponding filename].sql.go
{{output the corresponding sql.go}}

# Entity Definition
The function you are implementing refers to the following Entity. Below are the type definitions and the New function used to create the Entity:

{{list the contents of the entity file}}

# Transactions
All functions in the infrastructure interface are handled within a single transaction.
The transaction handling interface is defined in pkg/infra/txProvider.go as follows:

package infra

import (
	"context"
	"database/sql"

	_ "github.com/go-sql-driver/mysql"
	"github.com/naoto67/infra/go-sample/pkg/infra/db"
)

type Tx interface {
	db.DBTX
	Commit() error
	Rollback() error
}

type TxProvider interface {
	BeginTx(ctx context.Context, opts *sql.TxOptions) (Tx, error)
}

type RDBTxProvider struct {
	DB *sql.DB
}

var _ TxProvider = RDBTxProvider{}

func (p RDBTxProvider) BeginTx(ctx context.Context, opts *sql.TxOptions) (Tx, error) {
	return p.DB.BeginTx(ctx, opts)
}

# Implementation Guidelines
## General Guidelines
- Always create the Entity using the New function. Do not instantiate the struct directly.
- For queries that retrieve a single record by ID, first check the cache, and if it is not found, then issue a DB query.
- The cache key should be in the format "EntityType:EntityID".
- If the method argument is an entity type (for example, id entity.ChannelID), then if the corresponding record does not exist in the DB, return an error.
- If the method argument is a basic data type (for example, id string), then if the corresponding record does not exist in the DB, return nil or an empty slice rather than an error.

## Cache
The infrastructure implementation uses a cache to speed up access by avoiding direct DB queries.
The cache is defined in pkg/infra/cache.go as follows:

package infra

import "time"

type Cache interface {
	Set(k string, x interface{}, d time.Duration)
	Get(k string) (interface{}, bool)
}

## Implementation Pattern
Below is a high-level outline of the implementation. Note that this is only a guideline:

query := db.New(tx)
// Use cache if necessary. In some cases, caching may not be used.
cacheKey := fmt.Sprintf("EntityType:%d", id)
if cachedEntity, found := repo.Cache.Get(cacheKey); found {
    // If the cache contains the entity, return it.
}

// Call the DB query via its function
// For example: query.GetSomething(ctx)

// Convert the retrieved data to an Entity using the New function.

// If needed, store the entity in the cache. Set the cache duration appropriately.
repo.Cache.Set(cacheKey, entity, cacheDuration)

```

最終的に実装があれば置き換え、なければ追記する